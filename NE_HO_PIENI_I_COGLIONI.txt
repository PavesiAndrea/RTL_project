library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity project_reti_logiche is
Port ( i_clk : in STD_LOGIC;
i_rst : in STD_LOGIC;
i_start : in STD_LOGIC;
i_data : in STD_LOGIC_VECTOR (7 downto 0);
o_address : out STD_LOGIC_VECTOR (15 downto 0);
o_done : out STD_LOGIC;
o_en : out STD_LOGIC;
o_we : out STD_LOGIC;
o_data : out STD_LOGIC_VECTOR (7 downto 0));
end project_reti_logiche;

architecture Behavioral of project_reti_logiche is

type state_type is (START, IN_READ, GET_DIM,
CHECK_DIM_IN, CALC_DV_SHIFT,CHECK_DIM_OUT, NEW_VALUE, WRITE, FINE, START_WAIT);
signal state: state_type := START;
--signal state_curr: state;

signal MAX_PIXEL_VALUE: unsigned(7 downto 0);
signal MIN_PIXEL_VALUE: unsigned(7 downto 0);

begin

process(i_clk)

variable counter: integer;
variable delta_value : std_logic_vector(7 downto 0);
variable shift_level : integer;
variable temp_pixel : std_logic_vector(7 downto 0);
variable new_pixel_value : std_logic_vector(7 downto 0);
variable int_res: integer;
variable row: integer;
variable clmn: integer;
variable next_addr: std_logic_vector(15 downto 0);
variable temp_value: integer;
variable temp_value_vect: std_logic_vector(7 downto 0);

begin

    if rising_edge(i_clk) then o_done <= '0';
                               o_en <= '0';
                               o_we <= '0';
                               o_data <= (others => '0');
                               o_address <= (others => '0');
                               
    if(i_rst = '1') then state <= START; 
    
   else case state is                         
      
        when START => 
                      counter := 0; 
                      MAX_PIXEL_VALUE <= "00000000";
                      MIN_PIXEL_VALUE <= "11111111";                       
                      if (i_start = '1') then state <= GET_DIM;
                      else state <= START;
                      end if;
        
            when GET_DIM => 
                            o_en <= '1';
                            o_we <= '0';
                            o_address <= std_logic_vector(to_unsigned(counter,16));
                            clmn := to_integer(unsigned(i_data));
                            counter := counter +1;
                            o_address <= std_logic_vector(to_unsigned(counter,16));
                            row := to_integer(unsigned(i_data));
                            int_res := row*clmn;
                            counter := counter + 1;
                            state <= CHECK_DIM_IN;
        
            when CHECK_DIM_IN => 
                                 if(counter <= int_res) then state <= IN_READ;
                                 else state <= CALC_DV_SHIFT;
                                 
                                 end if;
                            
            when IN_READ => 
                            o_en <= '1';
                            o_we <= '0';
                            o_address <= std_logic_vector(TO_UNSIGNED(counter,16));
                            if(MIN_PIXEL_VALUE > unsigned(i_data)) then MIN_PIXEL_VALUE <= unsigned(i_data);
                            elsif (MAX_PIXEL_VALUE < unsigned(i_data)) then MAX_PIXEL_VALUE <= unsigned(i_data);
                            end if;
                            counter := counter + 1;
                            state <= CHECK_DIM_IN;
                        
                          
                            
            when CALC_DV_SHIFT => 
                                    delta_value := std_logic_vector(MAX_PIXEL_VALUE - MIN_PIXEL_VALUE);
                                    temp_value := to_integer(unsigned(delta_value));
                                    shift_level := 8;
                                    while temp_value>1 loop
                                        temp_value := temp_value/2;
                                        shift_level := shift_level - 1;
                                    end loop; 
                                    counter := 2;
                                    state <= CHECK_DIM_OUT;   
                            
            when CHECK_DIM_OUT => 
                                    if(counter < int_res) then state <= NEW_VALUE;
                                    else state <= FINE;
                                    end if;
        
            when NEW_VALUE => o_en <= '1';
                              o_we <= '1';
                              o_address <= std_logic_vector(to_unsigned(counter,16));
                              temp_value_vect := std_logic_vector(unsigned(i_data) - MIN_PIXEL_VALUE);
                              temp_pixel := std_logic_vector(shift_left(unsigned(temp_value_vect), shift_level));
                              if(temp_pixel < "11111111") then new_pixel_value := temp_pixel;
                              else new_pixel_value := "11111111";
                              end if;
                              state <= WRITE;
                              
            when WRITE => 
                            o_en <= '1';
                            o_we <= '1';
                            o_address <= std_logic_vector(to_unsigned(counter + int_res,16));
                            o_data <= new_pixel_value;
                            counter := counter +1;
                            state <= CHECK_DIM_OUT;
                                             
        
            when FINE => o_en <= '0';
                         o_we <= '0';
                         o_done <= '1';
                         state <= START_WAIT;
        
            when START_WAIT => if(i_start = '0')then o_done <= '0';
                                                     state <= START;
                                else state <= START_WAIT;
                                end if;
                                
        end case;
    end if;